target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    threading: false,
  }



import Encoders from "lib/Encoders.lf"
import GyroAngle from "lib/IMU.lf"
import MotorsWithFeedback from "lib/MotorsWithFeedback.lf"
import Motors from "lib/Motors.lf"
import Accelerometer from "lib/IMU.lf"
import Gyro from "lib/IMU.lf"
import Display from "lib/Display.lf"

preamble {=
  #include <math.h>
=}

reactor GyroControl {

  preamble {=
    const float K_ERROR = 0.4;
    const float K_D = 0.005;
  =}

    input vehicle_speed: float
    encoder = new Encoders()
    accel = new Accelerometer()
    mwf = new MotorsWithFeedback()
    m = new Motors()
    gyro = new GyroAngle()
    gyrov = new Gyro()
    d = new Display()

    timer t (0, 1 ms)
    
    encoder.left -> mwf.left;
    encoder.right -> mwf.right;

    reaction(t) -> encoder.trigger, gyro.trigger, gyrov.trigger {=
      lf_set(encoder.trigger, true);
      lf_set(gyro.trigger, true);
      lf_set(gyrov.trigger, true);
    =}

    reaction(startup) vehicle_speed -> m.left_power, m.right_power {=      
      lf_set(m.left_power, vehicle_speed->value);
      lf_set(m.right_power, vehicle_speed->value);
    =}
    
    reaction(gyro.y, gyro.x, gyro.z, gyrov.z) vehicle_speed -> m.left_power, m.right_power{=
        if (gyro.z->value > 0.1) {
          lf_set(m.left_power, vehicle_speed->value * (1.0 - 0.01 * fabs(gyro.z->value)));
          lf_set(m.right_power, vehicle_speed->value * (1.0 - K_ERROR * fabs(gyro.z->value)) - K_D * gyrov.z->value);
        } else if (gyro.z->value < -0.1) {
          lf_set(m.left_power, vehicle_speed->value * (1.0 - K_ERROR * fabs(gyro.z->value)) + K_D * gyrov.z->value);
          lf_set(m.right_power, vehicle_speed->value * (1.0 - 0.01 * fabs(gyro.z->value)));
        } else {
          lf_set(m.left_power, vehicle_speed->value);
          lf_set(m.right_power, vehicle_speed->value);
        }

    =}


}